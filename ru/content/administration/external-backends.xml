<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
  

<!-- $Id: external-backends.xml,v 1.2 2012-11-30 11:13:05 mb Exp $ -->
<section id="external-backends">
<title>Использование внешних хранилищ данных</title>

<section id='customer-data'>
<title>Данные клиентов</title>

<para>
OTRS работает с различными атрибутами данных клиентов, такими как имя
пользователя, адрес электронной почты, номер телефона и т.д. Эти атрибуты
отображаются в обеих фронтэндах, для Агентов и Клиентов. Они также
используются для проверки подлинности клиентов.
</para>

<para>
Данные клиентов, которые используются и отображаются в OTRS очень легко
настраиваются. Несмотря на это следующая информация будет всегда необходима
для проверки подлинности клиента:
</para>

<para>
<itemizedlist>
  <listitem>
    <para>
      Вход пользователей
    </para>
  </listitem>
  <listitem>
    <para>
      Адресс электронной почты
    </para>
  </listitem>
  <listitem>
    <para>
      ID Клиента
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Use the configuration parameters of the following script in your
<filename>Kernel/Config.pm</filename> file, if you want to display customer
information in your agent interface.
</para>

<para>
<programlisting>
    # Ticket::Frontend::CustomerInfo*
    # (show customer info on Compose (Phone and Email), Zoom and
    # Queue view)
    $Self->{'Ticket::Frontend::CustomerInfoCompose'} = 1;
    $Self->{'Ticket::Frontend::CustomerInfoZoom'} = 1;
    $Self->{'Ticket::Frontend::CustomerInfoQueue'} = 0;
</programlisting>
</para>

<para>
<emphasis>Сценарий: Конфигурационные параметры Kernel/Config.pm.</emphasis>
</para>

</section>

<section id="customer-user-backend">
<title>Пользовательский бэк-енд</title>

<para>
Вы можете использоваь два типа хранилища информации клиентов: Базу Данных DB
и LDAP. Если у вас уже есть другой бэк-енд для хранения пользовательской
информации (например SAP), также есть возможность написать модуль для
использования этой функции.  
</para>

<section id='customer-backend-db'>
<title>База Данных (По умолчанию)</title>

<para>
В Примере 11-1 приведена конфигурация базы данных, которая использует данные
клиента, хранящиеся в базе данных OTRS.
</para>

<example id='db-customer-backend'>
<title>Настройка клиентского хранилища базы данных (DB)</title>

<para>
<programlisting>
# CustomerUser (customer database backend and settings)
$Self->{CustomerUser} = {
    Name => 'Database Datasource',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the required settings
#            DSN => 'DBI:odbc:yourdsn',
#            Type => 'mssql', # only for ODBC connections
#            DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#            User => '',
#            Password => '',
            Table => 'customer_user',
            # if your frontend is unicode and the charset of your
            # customer database server is iso-8859-1, use these options.
#           SourceCharset => 'iso-8859-1',
#           DestCharset => 'utf-8',

            # CaseSensitive will control if the SQL statements need LOWER()
            #   function calls to work case insensitively. Setting this to
            #   1 will improve performance dramatically on large databases.
            CaseSensitive => 0,
        },
# customer unique id
CustomerKey => 'login',

# customer #
CustomerID => 'customer_id',
CustomerValid => 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title','first_name','last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [
        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',      1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name', 1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',  1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',      1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',         0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',      1, 1, 'var', '', 0 ],

#        [ 'UserEmail',      'Email', 'email',           1, 1, 'var', '$Env{"CGIHandle"}?Action=AgentTicketCompose&amp;ResponseID=1&amp;TicketID=$Data{"TicketID"}&amp;ArticleID=$Data{"ArticleID"}', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id', 0, 1, 'var', '', 0 ],

#        [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',        'Phone',       'phone',        1, 0, 'var', '', 0 ],
        [ 'UserFax',          'Fax',         'fax',          1, 0, 'var', '', 0 ],
        [ 'UserMobile',       'Mobile',      'mobile',       1, 0, 'var', '', 0 ],
        [ 'UserStreet',       'Street',      'street',       1, 0, 'var', '', 0 ],
        [ 'UserZip',          'Zip',         'zip',          1, 0, 'var', '', 0 ],
        [ 'UserCity',         'City',        'city',         1, 0, 'var', '', 0 ],
        [ 'UserCountry',      'Country',     'country',      1, 0, 'var', '', 0 ],
        [ 'UserComment',      'Comment',     'comments',     1, 0, 'var', '', 0 ],
        [ 'ValidID',          'Valid',       'valid_id',     0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};
</programlisting>
</para>

</example>

<para>
Если нужно настроить данные клиентов, измените заголовки столбцов или
добавьте новые к таблице customer_user базы данных OTRS. В качестве примера
используйте нижеприведенный сценарий, в котором показано как добавить новое
поле для номера комнаты.
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 116 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD room VARCHAR (250);
Query OK, 1 rows affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
<emphasis>Сценарий: Добавление поля "комната" в таблицу customer_user
table. </emphasis>
</para>

<para>
Теперь добавьте новый столбец в MAP-масив в
<filename>Kernel/Config.pm</filename>, как это показано в нижеприведенном
сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserRoom',      'Room',      'room',       0, 1, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление поля "комната" в файл Kernel/Config.pm
file.</emphasis>
</para>

<para>
It is also possible to edit all of this customer information via the
Customers link in the Agent interface.
</para>

<section id='multi-customer-ids-db'>
<title>Клиент с несколькими идентификаторами (Заявки Компании)</title>

<para>
Одному клиенту можно назначить больше одного клиентского идентификатора
(Customer ID). Это может быть полезно, если клиенту необходимо получить
доступ к заявкам других  клиентов, например, руководитель хочет посмотреть
заявки своих помощников. Если клиент может получить доступ к заявкам другого
клиента, то используется особенность OTRS "заявки компании". Заявки компании
могут быть доступны перейдя по ссылке "Заявки Компании" в клиентской панели
управления.
</para>

<para>
Для использованя заявок компании, новый столбец с идентификатором (IDs),
который должен быть доступен для клиента, должен быть добавлен в таблицу
customer_user базы данных OTRS (см. Сценарий ниже).
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 124 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD customer_ids VARCHAR (250);
Query OK, 1 rows affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
    <emphasis>Сценарий: Добавление поля customer_ids в таблицу
customer_user.</emphasis>
</para>

<para>
Теперь новый столбец должен быть добавлен в MAP-массив в
<filename>Kernel/Config.pm</filename>, как это показано в нижеприведенном
Сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление поля UserCustomerIDs в
Kernel/Config.pm</emphasis>
</para>

<para>
Теперь, новый столбец для мульти-идентификатора ( IDs) клиента можно
редактировать с помощью веб-интерфейса Агента, в разделе управления
клиентами.
</para>

<para>
Для того, чтобы убедится что один клиент имеет доступ к заявкам других
клиентов нужно добавить идентификаторы (IDs) этих пользователей в новое поле
для нескольких идентификаторов клиента. Каждый идентификатор (ID) должен
быть отделен точкой с запятой (см. ниже Пример 11-2).
</para>

<example id='company-tickets-db'>
<title>Хранение Заявок Компании в базе данных DB</title>

<para>
Клиенты А, Б и Ц созданы в вашей системе и А хочет иметь доступ к заявкам Б
и Ц используя клиентскую панель. Б и Ц не должны иметь доступа к заявкам
других пользователей.
</para>

<para>
Для реализации этой структуры, измените таблицу customer_user и маппинг
(преобразование) в <filename>Kernel/Config.pm</filename> как это показано
выше. С помощью Панели Администрирования или используя ссылку Клиенты в
веб-интерфейсе Агента загрузите настройки пользователя А. Если настройки
отображаются, добавьте значения "Б;Ц;" в поле для CustomerIDs.
</para>

</example>

</section>

</section>

<section id='customer-backend-ldap'>
<title>LDAP</title>

<para>
Если у вас есть LDAP­-каталог, в котором хранятся данные о клиентах, его
можно использовать в OTRS, в качестве хранилища данных о клиентах, как это
показано в Примере 11-3.
</para>

<example id='ldap-customer-backend'>
<title>Настройка LDAP в качестве клиентского бэк-енда</title>

<para>
<programlisting>
# CustomerUser
# (customer ldap backend and settings)
$Self->{CustomerUser} = {
    Name => 'LDAP Data Source',
    Module => 'Kernel::System::CustomerUser::LDAP',
    Params => {
        # ldap host
        Host => 'bay.csuhayward.edu',
        # ldap base dn
        BaseDN => 'ou=seas,o=csuh',
        # search scope (one|sub)
        SSCOPE => 'sub',
        # The following is valid but would only be necessary if the
        # anonymous user does NOT have permission to read from the LDAP tree
        UserDN => '',
        UserPw => '',
        # in case you want to add always one filter to each ldap query, use
        # this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
        AlwaysFilter => '',
            # if both your frontend and your LDAP are unicode, use this:
            SourceCharset => 'utf-8',
            DestCharset   => 'utf-8',
            # if your frontend is unicode and the charset of your
            # ldap server is iso-8859-1, use these options.
            # SourceCharset => 'iso-8859-1',
            # DestCharset => 'utf-8',
            # Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
            Params => {
                port => 389,
                timeout => 120,
                async => 0,
                version => 3,
            },
    },
    # customer unique id
    CustomerKey => 'uid',
    # customer #
    CustomerID => 'mail',
    CustomerUserListFields => ['cn', 'mail'],
    CustomerUserSearchFields => ['uid', 'cn', 'mail'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['mail'],
    CustomerUserNameFields => ['givenname', 'sn'],
    # show not own tickets in customer panel, CompanyTickets
    CustomerUserExcludePrimaryCustomerID => 0,
    # add an ldap filter for valid users (expert setting)
#    CustomerUserValidFilter => '(!(description=locked))',
    # administrator can't change customer preferences
    AdminSetPreferences => 0,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
    Map => [
        # note: Login, Email and CustomerID are mandatory!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
        [ 'UserTitle',      'Title',      'title',           1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'givenname',       1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'sn',              1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'uid',             1, 1, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'mail',            1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'mail',            0, 1, 'var', '', 0 ],
#        [ 'UserCustomerIDs', 'CustomerIDs', 'second_customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
        [ 'UserAddress',    'Address',    'postaladdress',   1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'description',     1, 0, 'var', '', 0 ],
    ],
};
</programlisting>
</para>

</example>

<para>
Если дополнительные атрибуты клиента хранятся в LDAP-каталоге, например, имя
руководителя, номер мобильного телефона, или отдела, и если эту информацию
нужно отобразить в OTRS, просто расширьте MAP-массив в файле
<filename>Kernel/Config.pm</filename> записями для этих атрибутов, как
показано в нижеприведенном сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление нового поля в файл
Kernel/Config.pm.</emphasis>
</para>


<section id='multi-customer-ids-ldap'>
<title>Клиент с несколькими идентификаторами (Заявки Компании)</title>

<para>
При использовании LDAP-бэкэнда клиенту можно присвоить больше одного
клиентского айди (Customer ID). Для использования заявок компании, в
LDAP-директорию нужно добавить новое поле, которое содержит доступные агенту
идентификаторы (IDs).
</para>

<para>
Если в LDAP-каталоге было созадно новое поле, его также нужно добавить в
MAP-массив в <filename>Kernel/Config.pm</filename>, как это показано в
нижеприведенном сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Подстановка новых полей в Kernel/Config.pm
file.</emphasis>
</para>

<para>
Клиентские идентификаторы (IDs) можно редактировать напрямую в
LDAP-директории. OTRS может только считать информацию из LDAP, но не
записывать.
</para>

<para>
Чтобы убедтися что клиент имеет доступ к заявкам других клиентов, добавьте
идентификаторы (IDs) клиентов, к заявкам которых нужен доступ, к новому полю
вашей LDAP-директории. Каждый идентификатор ID должен быть отделен точнкой с
запятой (см. ниже Рисунок 11-4).
</para>

<example id='company-tickets-ldap'>
<title>Использование заявок Компании с LDAP-бэкэндом</title>

<para>
Клиенты А, Б и Ц созданны в вашей системе и А хочет иметь доступ к заявкам Б
и Ц через панель клиента. Б и Ц не должны иметь доступа к другим
пользователям.
</para>

<para>
Для реализации этой установки измените LDAP-директорию и маппинг (mapping) в
<filename>Kernel/Config.pm</filename>, как это показано выше. Затем добавьте
в вашей LDAP-директории значения "Б;Ц;" в поле для CustomerIDs, для клиента
"А".
</para>

</example>

</section>

</section>

<section id='multiple-customer-backends'>
<title>Использование больше чем одного пользовательского хранилища данных с OTRS</title>

<para>
Если в OTRS нужно использовать больше одного источника данных о клиентах
(например LDAP и базу данных), конфигурационный параметр CustomerUser должен
быть расширен числом, например "CustomerUser1", "CustomerUser2" (см. ниже
Пример 11-5).
</para>

<example id='multiple-customer-backend-example'>
<title>Использование больше чем одного пользовательского хранилища данных с OTRS</title>

<para>
В следующем примере показано применение конфигурации как для LDAP так и для
базы данных клиентского бэкэнда с OTRS.
</para>

<para>
<programlisting>
# 1. Customer user backend: DB
# (customer database backend and settings)
$Self->{CustomerUser1} = {
    Name => 'Customer Database',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the
        # required settings
#        DSN => 'DBI:odbc:yourdsn',
#        Type => 'mssql', # only for ODBC connections
#        DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#        User => '',
#        Password => '',
        Table => 'customer_user',
    },
    # customer unique id
    CustomerKey = 'login',
    # customer #
    CustomerID = 'customer_id',
    CustomerValid = 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title','first_name','last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [

        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',        1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name',   1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',    1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',        1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',           0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',        1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id',  0, 1, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'phone',        1, 0, 'var', '', 0 ],
        [ 'UserFax',        'Fax',        'fax',          1, 0, 'var', '', 0 ],
        [ 'UserMobile',     'Mobile',     'mobile',       1, 0, 'var', '', 0 ],
        [ 'UserStreet',     'Street',     'street',       1, 0, 'var', '', 0 ],
        [ 'UserZip',        'Zip',        'zip',          1, 0, 'var', '', 0 ],
        [ 'UserCity',       'City',       'city',         1, 0, 'var', '', 0 ],
        [ 'UserCountry',    'Country',    'country',      1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'comments',     1, 0, 'var', '', 0 ],
        [ 'ValidID',        'Valid',      'valid_id',     0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};

# 2. Customer user backend: LDAP
# (customer ldap backend and settings)
$Self->{CustomerUser2} = {
    Name => 'LDAP Datasource',
    Module => 'Kernel::System::CustomerUser::LDAP',
    Params => {
        # ldap host
        Host => 'bay.csuhayward.edu',
        # ldap base dn
        BaseDN => 'ou=seas,o=csuh',
        # search scope (one|sub)
        SSCOPE => 'sub',
#        # The following is valid but would only be necessary if the
#        # anonymous user does NOT have permission to read from the LDAP tree
        UserDN => '',
        UserPw => '',
        # in case you want to add always one filter to each ldap query, use
        # this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
        AlwaysFilter => '',
        # if both your frontend and your LDAP are unicode, use this:
#        SourceCharset => 'utf-8',
#        DestCharset   => 'utf-8',
        # if your frontend is e. g. iso-8859-1 and the character set of your
        # ldap server is utf-8, use these options:
#        SourceCharset => 'utf-8',
#        DestCharset => 'iso-8859-1',

        # Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
        Params => {
            port => 389,
            timeout => 120,
            async => 0,
            version => 3,
        },
    },
    # customer unique id
    CustomerKey => 'uid',
    # customer #
    CustomerID => 'mail',
    CustomerUserListFields => ['cn', 'mail'],
    CustomerUserSearchFields => ['uid', 'cn', 'mail'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['mail'],
    CustomerUserNameFields => ['givenname', 'sn'],
    # show not own tickets in customer panel, CompanyTickets
    CustomerUserExcludePrimaryCustomerID => 0,
    # add a ldap filter for valid users (expert setting)
#    CustomerUserValidFilter => '(!(description=locked))',
    # admin can't change customer preferences
    AdminSetPreferences => 0,
    Map => [
        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
        [ 'UserTitle',      'Title',      'title',           1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'givenname',       1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'sn',              1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'uid',             1, 1, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'mail',            1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'mail',            0, 1, 'var', '', 0 ],
#        [ 'UserCustomerIDs', 'CustomerIDs', 'second_customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
        [ 'UserAddress',    'Address',    'postaladdress',   1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'description',     1, 0, 'var', '', 0 ],
    ],
};
</programlisting>
</para>

</example>

<para>
Есть возможность интегрировать до 10 различных пользовательских
бэк-эндов. Используйте интерфейс управления клиентами в OTRS, чтобы
просматривать и редактировать данные о них (при условии наличия прав для
записи).
</para>

</section>

</section>

<section id="auth-backends">
<title>Хранилища (бэк-енды) для аутентификации Агентов и Клиентов</title>

<para>
OTRS предлагает опцию для проверки подлинности агентов и клиентов с
использованием различных хранилищ данных (бэкендов).
</para>

<section id='agent-auth-backends'>
<title>Хранилища данных (бэк-енды) для аутентификации Агентов</title>

<section id='agent-auth-backend-db'>
<title>База Данных (DB, по умаолчанию)</title>

<para>
В качестве бэк-энда для аутентификации агентов в OTRS, по умолчанию,
используется база данных. Чтобы добавлять агентов, редактировать данные о
них, перейдите на страницу <link linkend="adminarea">Панель
Администрирования</link> и нажмите ссылку <link
linkend="adminarea-agents">Интерфейс для управления агентами</link>
(см. ниже Пример 11.6).
</para>

<example id='configuration-agent-auth-backend-db'>
<title>Проверка подлинности агентов путем использования Базы Данных (DB) в качестве
хранилища информации.</title>

<para>
<programlisting>
    $Self->{'AuthModule'} = 'Kernel::System::Auth::DB';
</programlisting>
</para>

</example>

</section>

<section id='agent-auth-backend-ldap'>
<title>LDAP</title>

<para>
Если данные всех ваших агентов хранятся в LDAP-директории, то для
аутентификации пользователей в OTRS можно использовать LDAP-модуль (см. ниже
Пример 11-7). Этот модуль имеет права только на чтение дерева
LDAP-каталогов, что означает что нету возможности редактировать данные
пользователей используя ссылку <link linkend='adminarea-agents'>
веб-интерфейс для управления пользователями </link> .
</para>

<example id='configuration-agent-auth-backend-ldap'>
<title>Проверка подлинности агентов при использовании LDAP в качестве хранилища
данных</title>

<para>
<programlisting>
# This is an example configuration for an LDAP auth. backend.
# (Make sure Net::LDAP is installed!)
$Self->{'AuthModule'} = 'Kernel::System::Auth::LDAP';
$Self->{'AuthModule::LDAP::Host'} = 'ldap.example.com';
$Self->{'AuthModule::LDAP::BaseDN'} = 'dc=example,dc=com';
$Self->{'AuthModule::LDAP::UID'} = 'uid';

# Check if the user is allowed to auth in a posixGroup
# (e. g. user needs to be in a group xyz to use otrs)
$Self->{'AuthModule::LDAP::GroupDN'} = 'cn=otrsallow,ou=posixGroups,dc=example,dc=com';
$Self->{'AuthModule::LDAP::AccessAttr'} = 'memberUid';
# for ldap posixGroups objectclass (just uid)
#  $Self->{'AuthModule::LDAP::UserAttr'} = 'UID';
# for non ldap posixGroups objectclass (with full user dn)
#  $Self->{'AuthModule::LDAP::UserAttr'} = 'DN';

# The following is valid but would only be necessary if the
# anonymous user do NOT have permission to read from the LDAP tree
$Self->{'AuthModule::LDAP::SearchUserDN'} = '';
$Self->{'AuthModule::LDAP::SearchUserPw'} = '';

# in case you want to add always one filter to each ldap query, use
# this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
$Self->{'AuthModule::LDAP::AlwaysFilter'} = '';

# in case you want to add a suffix to each login name, then
# you can use this option. e. g. user just want to use user but
# in your ldap directory exists user@domain.
#    $Self->{'AuthModule::LDAP::UserSuffix'} = '@domain.com';

# Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
$Self->{'AuthModule::LDAP::Params'} = {
    port => 389,
    timeout => 120,
    async => 0,
    version => 3,
};
</programlisting>
</para>

</example>

<para>
The configuration parameters shown in the script below can be used to
synchronize the user data from your LDAP directory into your local OTRS
database. This reduces the number of requests to your LDAP server and speeds
up the authentication with OTRS. The data synchronization is done when the
agent authenticates the first time. Although the data can be syncronized
into the local OTRS database, the LDAP directory is the last instance for
the authentication, so an inactive user in the LDAP tree can't authenticate
to OTRS, even when the account data is already stored in the OTRS
database. The agent data in the LDAP directory can't be edited via the web
interface of OTRS, so the data has to be managed directly in the LDAP tree.
</para>

<para>
<programlisting>
# defines AuthSyncBackend (AuthSyncModule) for AuthModule
# if this key exists and is empty, there won't be a sync.
# example values: AuthSyncBackend, AuthSyncBackend2
$Self->{'AuthModule::UseSyncBackend'} = 'AuthSyncBackend';

# agent data sync against ldap
$Self->{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
$Self->{'AuthSyncModule::LDAP::Host'} = 'ldap://ldap.example.com/';
$Self->{'AuthSyncModule::LDAP::BaseDN'} = 'dc=otrs, dc=org';
$Self->{'AuthSyncModule::LDAP::UID'} = 'uid';
$Self->{'AuthSyncModule::LDAP::SearchUserDN'} = 'uid=sys, ou=user, dc=otrs, dc=org';
$Self->{'AuthSyncModule::LDAP::SearchUserPw'} = 'some_pass';
$Self->{'AuthSyncModule::LDAP::UserSyncMap'} = {
    # DB -> LDAP
    UserFirstname => 'givenName',
    UserLastname  => 'sn',
    UserEmail     => 'mail',
};
[...]

# AuthSyncModule::LDAP::UserSyncInitialGroups
# (sync following group with rw permission after initial create of first agent
# login)
$Self->{'AuthSyncModule::LDAP::UserSyncInitialGroups'} = [
    'users',
];
</programlisting>
</para>

<para>
<emphasis>Сценарий: Синхронизация пользовательских данных из
LDAP-директориив базу данных OTRS.</emphasis>
</para>

</section>

<section id='agent-auth-backend-httpbasic'>
<title>HTTPBasicAuth-аутентификация для Агентов</title>

<para>
Если вы хотите реализовать решение "single sign on" для всех агентов, вы
можете использовать базовую аунентификацию (для всех систем) и
HTTPBasicAuth-модуль для OTRS (см. ниже Пример 11-8).
</para>

<example id='configuration-agent-auth-backend-htbasic'>
<title>Аутентификация Агентов с помощью HTTPBasic</title>

<para>
<programlisting>
# This is an example configuration for an apache ($ENV{REMOTE_USER})
# auth. backend. Use it if you want to have a singe login through
# apache http-basic-auth
$Self->{'AuthModule'} = 'Kernel::System::Auth::HTTPBasicAuth';

# Note:
#
# If you use this module, you should use as fallback
# the following configuration settings if the user is not authorized
# apache ($ENV{REMOTE_USER})
$Self->{LoginURL} = 'http://host.example.com/not-authorised-for-otrs.html';
$Self->{LogoutURL} = 'http://host.example.com/thanks-for-using-otrs.html';
</programlisting>
</para>

</example>

</section>

<section id='agent-auth-backend-radius'>
<title>Radius</title>

<para>
Параметры конфигурации приведенные в Примере 11-9 могут быть использованы
для аутентификации агентов с использованием Radius-сервера.
</para>

<example id='configuration-agent-auth-backend-radius'>
<title>Аутентификация (проверка подлинности) агентов с использованием
Radius-сервера в качестве хранилища информации</title>

<para>
<programlisting>
# This is example configuration to auth. agents against a radius server
$Self->{'AuthModule'} = 'Kernel::System::Auth::Radius';
$Self->{'AuthModule::Radius::Host'} = 'radiushost';
$Self->{'AuthModule::Radius::Password'} = 'radiussecret';
</programlisting>
</para>

</example>

</section>

</section>

<section id="customer-auth-backends">
<title>Хранилища информации для аутентификации (проверки подлинности) клиентов</title>

<section id='customer-auth-backend-db'>
<title>База Данных (По умолчанию)</title>

<para>
Для аутентификации клиентов в OTRS, по умолчанию, используется база
данных. Используя базу данных в качестве хранилища,  все данные клиентов
можно редактировать через веб-интерфейс OTRS (см. ниже Пример 11-10).
</para>

<example id='configuration-customer-auth-backend-db'>
<title>Аутентификация Клиента в Базе Данных</title>

<para>
<programlisting>
# This is the auth. module againt the otrs db
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::DB';
$Self->{'Customer::AuthModule::DB::Table'} = 'customer_user';
$Self->{'Customer::AuthModule::DB::CustomerKey'} = 'login';
$Self->{'Customer::AuthModule::DB::CustomerPassword'} = 'pw';
#$Self->{'Customer::AuthModule::DB::DSN'} = "DBI:mysql:database=customerdb;host=customerdbhost";
#$Self->{'Customer::AuthModule::DB::User'} = "some_user";
#$Self->{'Customer::AuthModule::DB::Password'} = "some_password";
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-ldap'>
<title>LDAP</title>

<para>
Если у вас есть LDAP-каталог со всеми данными о клиентах, можно использовать
модуль LDAP для аутентификации клиентов в OTRS (см. Пример 11-11
ниже). Поскольку этот модуль имеет права только для чтения для данных из
LDAP-бэкенда, то нету возможности изменить данные клиента через веб.
</para>

<example id='configuration-customer-auth-backend-ldap'>
<title>Аутентификация пользователей с помощью LDAP-бэкэнда</title>

<para>
<programlisting>
# This is an example configuration for an LDAP auth. backend.
# (make sure Net::LDAP is installed!)
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::LDAP';
$Self->{'Customer::AuthModule::LDAP::Host'} = 'ldap.example.com';
$Self->{'Customer::AuthModule::LDAP::BaseDN'} = 'dc=example,dc=com';
$Self->{'Customer::AuthModule::LDAP::UID'} = 'uid';

# Check if the user is allowed to auth in a posixGroup
# (e. g. user needs to be in a group xyz to use otrs)
$Self->{'Customer::AuthModule::LDAP::GroupDN'} = 'cn=otrsallow,ou=posixGroups,dc=example,dc=com';
$Self->{'Customer::AuthModule::LDAP::AccessAttr'} = 'memberUid';
# for ldap posixGroups objectclass (just uid)
$Self->{'Customer::AuthModule::LDAP::UserAttr'} = 'UID';
# for non ldap posixGroups objectclass (full user dn)
#$Self->{'Customer::AuthModule::LDAP::UserAttr'} = 'DN';

# The following is valid but would only be necessary if the
# anonymous user does NOT have permission to read from the LDAP tree
$Self->{'Customer::AuthModule::LDAP::SearchUserDN'} = '';
$Self->{'Customer::AuthModule::LDAP::SearchUserPw'} = '';

# in case you want to add always one filter to each ldap query, use
# this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
$Self->{'Customer::AuthModule::LDAP::AlwaysFilter'} = '';

# in case you want to add a suffix to each customer login name, then
# you can use this option. e. g. user just want to use user but
# in your ldap directory exists user@domain.
#$Self->{'Customer::AuthModule::LDAP::UserSuffix'} = '@domain.com';

# Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
$Self->{'Customer::AuthModule::LDAP::Params'} = {
    port => 389,
    timeout => 120,
    async => 0,
    version => 3,
};
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-httpbasic'>
<title>HTTPBasicAuth аутентификация для клиентов</title>

<para>
Если для пользователей нужно внедрить "single sign on"-решение, можно
использовать базовую, HTTPBasic аутентификацию (для всех систем) и
использовать модуль HTTPBasicAuth с OTRS (больше не нужно логинится в
OTRS). См. ниже Пример 11-12.
</para>

<example id='configuration-customer-auth-backend-htbasic'>
<title>Аутентификация клиентов с помощью HTTPBasic</title>

<para>
<programlisting>
# This is an example configuration for an apache ($ENV{REMOTE_USER})
# auth. backend. Use it if you want to have a singe login through
# apache http-basic-auth
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::HTTPBasicAuth';

# Note:
# If you use this module, you should use the following
# config settings as fallback, if user isn't login through
# apache ($ENV{REMOTE_USER})
$Self->{CustomerPanelLoginURL} = 'http://host.example.com/not-authorised-for-otrs.html';
$Self->{CustomerPanelLogoutURL} = 'http://host.example.com/thanks-for-using-otrs.html';
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-radius'>
<title>Radius</title>

<para>
Настройки приведенные в примере 11-13 могут быть использованы для
аутентификации ваших клиентов с помощью Radius-сервера.
</para>

<example id='configuration-customer-auth-backend-radius'>
<title>Аутентификация клиентов с использованием Radius</title>

<para>
<programlisting>
# This is a example configuration to auth. customer against a radius server
$Self->{'Customer::AuthModule'} = 'Kernel::System::Auth::Radius';
$Self->{'Customer::AuthModule::Radius::Host'} = 'radiushost';
$Self->{'Customer::AuthModule::Radius::Password'} = 'radiussecret';
</programlisting>
</para>

</example>

</section>

</section>

</section>

<section id="customer-self-registration">
<title>Настройка самостоятельной регистрации клиента</title>

<para>
Есть возможность настроить самостоятельную регистрацию новых клиентов,
доступную через панель customer.pl. Можно добавить новые дополнительные или
обязательные поля, такие как номер комнаты, адрес или состояние.
</para>

<para>
В следующем примере показано каким образом можно указать обязательные для
заполнения поля в базе данных клиентов, в данном случае, для хранения номера
клиента. 
</para>

<section id='customer-self-registration-dtl'>
<title>Настройка веб-интерфейса</title>

<para>
Для отображения нового поля для номера комнаты в веб-интерфейсе пользователя
(customer.pl), нужно внести изменения в .dtl-файл, который отвечает за
шаблон этого интерфейса. Отредактируйте файл
<filename>Kernel/Output/HTML/Standard/CustomerLogin.dtl</filename> добавив
новые поля после строки 80 (см. нижеприведенный сценарий).
</para>

<para>
<programlisting>
[...]
&lt;div class="NewLine"&gt;
    &lt;label for="Room"&gt;$Text{"Room{CustomerUser}"}&lt;/label&gt;
    &lt;input title="$Text{"Room Number"}" name="Room" type="text" id="UserRoom" maxlength="50" /&gt;
&lt;/div&gt;
[...]
</programlisting>
</para>

<para>
<emphasis>Сценарий: Отображение новых полей в веб-интерфейсе.</emphasis>
</para>

</section>

<section id="customer-self-registration-mapping">
<title>Отображения клиентов</title>

<para>
На следующем этапе, нужно внести изменения в маппинг (mapping), рассширив
его новым элементом - номером комнаты. Чтобы убедится что изменения не
потеряются после обновления, установите настройкы "CustomerUser" из файла
<filename>Kernel/Config/Defaults.pm</filename> в файл
<filename>Kernel/Config.pm</filename>. Теперь измените MAP-массив, добавив
новое поле - номер комнаты, как это показано в нижеприведенном сценарии.
</para>

<para>
<programlisting>
# CustomerUser
# (customer database backend and settings)
$Self->{CustomerUser} = {
    Name => 'Database Backend',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the
        # required settings
#        DSN => 'DBI:odbc:yourdsn',
#        Type => 'mssql', # only for ODBC connections
#        DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#        User => '',
#        Password => '',
        Table => 'customer_user',
    },
    # customer unique id
    CustomerKey => 'login',
    # customer #
    CustomerID => 'customer_id',
    CustomerValid => 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
#    CustomerUserListFields => ['login', 'first_name', 'last_name', 'customer_id', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title', 'first_name', 'last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [

        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',       1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name',  1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',   1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',       1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',          0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',       1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id', 0, 1, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'phone',       1, 0, 'var', '', 0 ],
        [ 'UserFax',        'Fax',        'fax',         1, 0, 'var', '', 0 ],
        [ 'UserMobile',     'Mobile',     'mobile',      1, 0, 'var', '', 0 ],
        [ 'UserRoom',       'Room',       'room',        1, 0, 'var', '', 0 ],
        [ 'UserStreet',     'Street',     'street',      1, 0, 'var', '', 0 ],
        [ 'UserZip',        'Zip',        'zip',         1, 0, 'var', '', 0 ],
        [ 'UserCity',       'City',       'city',        1, 0, 'var', '', 0 ],
        [ 'UserCountry',    'Country',    'country',     1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'comments',    1, 0, 'var', '', 0 ],
        [ 'ValidID',        'Valid',      'valid_id',    0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};
</programlisting>
</para>

<para>
<emphasis>Сценарий: Внесение изменений в map-массив.</emphasis>
</para>

</section>

<section id="customer-self-registration-customer-table">
<title>Настройка таблицы customer_user в Базе Данных OTRS DB</title>

<para>
Последним шагом является добавление нового столбца с номером комнаты в
таблицу customer_user базы данных OTRS (см. нижеприведенный сценарий). В
этой колонке будет хранится информация для номера комнаты.
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 6 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD room VARCHAR (200);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
<emphasis>Сценарий: Добавление новой колонки в таблицу
customer_user.</emphasis>
</para>

<para>
Теперь новое поле для номера комнаты должно отображатся в customer.pl
панели. Когда новые клиенты будут регистрировать аккаунт, им нужно будет
вписать номер комнаты. Если для работы OTRS используется Apache и  модуль
mod_perl, то чтобы новые изменения вступили в силу нужно перезапустить
веб-сервер.
</para>
</section>

</section>

</section>
